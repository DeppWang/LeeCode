# 91. 解码方法

https://leetcode-cn.com/problems/decode-ways/

```
'A' -> 1
'B' -> 2
...
'Z' -> 26
```

![image-20191214185640316](https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2019-12-22-020848.jpg)

### 思路

- 标签：`动态规划、队列`
- 动态规划：通过子问题解决父问题，即父问题的答案可以通过子问题得到
- **从后往前遍历**，从倒数第 2 个开始，默认最右边隐含 1
- 0 开头的子序列解码方法数始终为 0
- 当前子序列默认总和为上一个子序列总和，如果当前与上一个的组合值大于 0，小于 26，当前子序列总和为上一个和上上个子序列总和相加。（例如：901，90 > 26，默认为上一个子序列 01 的和 0）
- 利用队列存放前两个子序列的总和
- 时间复杂度：O(n)，遍历一遍就能得到结果
- 空间复杂度：O(1)，队列的长度始终为 2

### 代码

```Java
// Java
class Solution {
    public int numDecodings(String s) {
        char[] charArr = s.toCharArray();
        if (s.equals("") || charArr[0] == '0') {
            return 0;
        }
        int index = charArr.length - 1;
        int preNumber = Character.getNumericValue(charArr[index]);
        Deque<Integer> preSumStack = new LinkedList<>();
        preSumStack.add(1);
        preSumStack.add(preNumber == 0 ? 0 : 1);
        while (index > 0) {
            int currNumber = Integer.parseInt(String.valueOf(charArr[index - 1]));
            int currSum = preSumStack.getLast();
            if (currNumber == 0) {
                currSum = 0;
            } else {
                int newNumber = currNumber * 10 + preNumber;
                if (newNumber > 0 && newNumber <= 26) {
                    currSum = preSumStack.getFirst() + preSumStack.getLast();
                }
            }
            preSumStack.removeFirst();
            preSumStack.add(currSum);
            preNumber = currNumber;
            index = index - 1;
        }
        return preSumStack.getLast();
    }
}
```

