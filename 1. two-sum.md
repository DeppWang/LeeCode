<!------->
<!--title: 画解算法：1. 两数之和-->
<!--english_title: two-sum-->
<!--date: 2019-07-07 13:26:55-->
<!--tags: LeetCode -->
<!--categories: Algorithms & DataStructure-->
<!------->
# 画解算法：1. 两数之和
难度：<span style="color: green">简单</span>  &nbsp;&nbsp; 相关标签：`数组`、`哈希表`
## 题目链接
https://leetcode-cn.com/problems/two-sum/

## 题目描述
给定一个整数数组 `nums` 和一个目标值 `target`，请你在该数组中找出和为目标值的那 **两个** 整数，并返回他们的数组下标。

你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。

*示例：*

```
给定 nums = [2, 7, 11, 15], target = 9

因为 nums[0] + nums[1] = 2 + 7 = 9
所以返回 [0, 1]
```
<!--more-->
## 解题方案

### 思路 1：两层 for 循环
* 标签：`数组`
* 利用两层 for 循环，遍历每一个元素，再将差值与其后元素一一比对，也称为「暴力法」
* 时间复杂度为：O(n^2)：n + (n-1) + .... + 1

<!--more-->
### 代码
**Java:**
```Java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        for (int i = 0; i < nums.length; i++) {
            for (int j = i + 1; j < nums.length; j++) {
                if (nums[j] == target - nums[i]) {
                    return new int[]{i, j}; // 返回数组最简洁的方式
                }
            }
        }
        throw new IllegalArgumentException("No two sum solution"); // 非法参数异常：整数数组和目标值不符合条件
    }
}
```
**JavaScript:**
```JavaScript
var twoSum = function (nums, target) {
    for (let i = 0; i < nums.length; i++) {
        for (let j = i + 1; j < nums.length; j++) {
            if (nums[j] === target - nums[i]) {
                return [i, j];
            }
        }
    }
};
```
### 思路 2：两遍哈希表
* 标签：`哈希表`
* 「暴力法」时间复杂度高，因为差值要一一和其后元素比较，如果差值一次就能和其他所有元素比较，那么时间复杂度为 O(n)
* 可以利用哈希表的 contains() 实现此功能
* 因为需要返回索引，所以元素和索引要相关联，所以使用 Map 结构
* 因为要返回索引，假设索引作为 key，元素作为 value，**不能根据 value（元素）反推其 key（索引）**，所以元素作为 key，索引作为 value
* 虽然数组中元素可重复，重复元素作为 key 加入 map 时，**value（索引）更新，此时索引代表重复元素**。所以重复元素无影响
* 两遍哈希表，第一遍将数据存放到 map 中，第二遍使用 contains() 方法
* 时间复杂度：O(n)

### 代码
**Java:**
```Java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer, Integer> map = new HashMap<>(); // 引用对象使用 <Integer, Integer> 可指定存储类型
        for (int i = 0; i < nums.length; i++) {
            map.put(nums[i], i); // 元素作为 key，索引作为 value
        }
        for (int i = 0; i < nums.length; i++) {
            int key = target - nums[i];
            // map.containsKey(key) 相当于 map.keySet().contains(key)；
            // 利用 && 特性：如果 map.containsKey(key) 为 false，map.get(key) 将不执行，避免空指针异常；
            // map.get(key) != i: 索引不同，确保不是同一个元素
            if (map.containsKey(key) && map.get(key) != i) { 
                return new int[]{i, map.get(key)};
            }
        }
        throw new IllegalArgumentException("No two sum solution");
    }
}
```
**JavaScript:**
```JavaScript
var twoSum = function (nums, target) {
    var map = new Map();
    for (let i = 0; i < nums.length; i++) {
        map.set(nums[i], i);
    }
    for (let i = 0; i < nums.length; i++) {
        let key = target - nums[i];
        if (map.has(key) && map.get(key) !== i) {
            return [i, map.get(key)];
        }
    }
};
```
### 画解
![WeChat Image_20190802194727.png](https://i.loli.net/2019/08/02/5d4422dd22b7854925.png)
### 思路 3：一遍哈希表
* 标签：`哈希表`
* 可将第一遍哈希省略，每次循环，将元素、索引存于 map，当前元素可与 **map 中已加入**的元素比较
* 时间复杂度：O(n)

### 代码
**Java:**
```Java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer, Integer> map = new HashMap<>();
        for (int i = 0; i < nums.length; i++) {
            int key = target - nums[i];
            if (map.containsKey(key)) { // 跟 map 中已加入元素比较，肯定不是同一个元素，所以不比较索引
                return new int[]{map.get(key), i}; // i在后
            }
            map.put(nums[i], i);
        }
        throw new IllegalArgumentException("No two sum solution");
    }
}
```
**JavaScript:**
```JavaScript
var twoSum = function (nums, target) {
    var map = new Map();
    for (let i = 0; i < nums.length; i++) {
        let key = target - nums[i];
        if (map.has(key) && map.get(key) !== i) {
            return [map.get(key), i];
        }
        map.set(nums[i], i);
    }
};
```
### 画解
* 请看灵魂画师牧码的 [画解](https://leetcode-cn.com/problems/two-sum/solution/jie-suan-fa-1-liang-shu-zhi-he-by-guanpengchn/)

### 测试用例
描述 | 1 | 2 | 3 | 4
---|---|---|---|---
nums | [2, 7, 11, 15] | [3, 2, 4] | [3, 3]  | [2, 5, 5, 11]
target | 9 | 6 | 6 | 10
预期结果 | [0, 1] | [1, 2] | [0, 1] | [1, 2]
