## 1、两次for循环
最开始想到的就是利用两次for循环，遍历每一个元素，再与其后元素一一比对，也称为“暴力法”。时间复杂度为O(n^2)：n + (n-1) + .... + 1。
```
class Solution {
    public int[] twoSum(int[] nums, int target) {
        for (int i = 0; i < nums.length; i++) {
            for (int j = i + 1; j < nums.length; j++) {
                if (nums[i] + nums[j] == target) {
                    return new int[]{i, j};//返回数组最简洁
                }
            }
        }
        throw new IllegalArgumentException("No two sum solution");//非法参数异常
    }
}
```
## 2、两遍哈希表
“暴力法”时间复杂度高，因为每个元素一一和其后元素比较，如果一次就能和所有元素比较，那么时间复杂度为O(n)。哈希表有此功能，元素和索引要相关联，所以使用Map。两遍哈希表，第一遍将数据存放到map中，第二遍使用contains方法。
```
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer, Integer> map = new HashMap<>();//引用对象使用<Integer, Integer>可指定存储类型
        for (int i = 0; i < nums.length; i++) {
            map.put(nums[i], i);//nums[i]做key，虽nums[i]可重复，但此时value为第二个索引，可区分；nums[i]为value，不能根据value反推key（索引）。
        }
        for (int i = 0; i < nums.length; i++) {
            int key = target - nums[i];
            //map.keySet().contains(key)；利用&&特性：如果map.containsKey(key)为false，map.get(key)将空指针异常；map.get(key) != i: 索引不同，确保不是同一个元素
            if (map.containsKey(key) && map.get(key) != i) { 
                return new int[]{i, map.get(key)};
            }
        }
        throw new IllegalArgumentException("No two sum solution");
    }
}
```
## 3、一遍哈希表
可将第一遍哈希省略，每次循环，将元素、索引存于map，当前元素可与**前面**的元素比较。
```
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer, Integer> map = new HashMap<>();
        for (int i = 0; i < nums.length; i++) {
            int key = target - nums[i];
            if (map.containsKey(key)) {//跟前面元素比较，肯定不是同一个元素，所以不比较索引
                return new int[]{map.get(key), i};//i在后
            }
            map.put(nums[i], i);
        }
        throw new IllegalArgumentException("No two sum solution");
    }
}
```
## 测试用例
描述 | 1 | 2 | 3 | 4
---|---|---|---|---
nums | [2, 7, 11, 15] | [3, 2, 4] | [3, 3]  | [2, 5, 5, 11]
target | 9 | 6 | 6 | 10

