# 画解算法：7. 整数反转
## 题目链接
https://leetcode-cn.com/problems/reverse-integer/
## 题目描述
给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。

*示例 1:*
```
输入: 123
输出: 321
```
*示例 2:*
```
输入: -123
输出: -321
```
*示例 3:*
```
输入: 120
输出: 21
```

**注意:**

假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−2<sup>31</sup>, 2<sup>31</sup> − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。

## 解题方案
### 思路
* 标签：数学
* 直接使用字符串的 reversie() 反转很简单，但这种方式调用了底层函数，效率低
* 使用数学的方式，`x` 依次除 10 取余，结果`rev` 依次乘 10 加余 `pop`。需要考虑溢出问题。
* `rev * 10 + pop > Integer.MAX_VALUE` 会溢出
  * 不能直接用 `rev * 10 + pop`，要使用`rev > (Integer.MAX_VALUE - pop)  / 10`
  * `- pop` 为正数时，溢出，省略 `- pop`，使用 `rev > Integer.MAX_VALUE / 10`
* 当 `rev = Integer.MAX_VALUE / 10` 时，`pop` 应小于最大值的个位数，即 `rev == 214748364` 时，`pop` 应该小于 `7`（`Integer.MAX_VALUE == 2147483647`）。假设 `pop` 等于 `8` , 那么`x == 8463847412` , 远远大于 `2147483647`，所以这种情况不存在，只要 `x` 值为正常值，`pop` 总是小于 `7`。
* `rev * 10 + pop < Integer.MIN_VALUE` 也会溢出
  * 同理，`rev < Integer.MIN_VALUE / 10`
* 同理，`rev = Integer.MIN_VALUE / 10` 时，`Math.abs(pop)` 总是小于 8（Integer.MIN_VALUE = -2147483648）。

### 代码
```
class Solution {
    public int reverse(int x) {
        int rev = 0;
        while (x != 0) {

            int pop = x % 10;
            if (rev > Integer.MAX_VALUE / 10) {
                return 0;
            }
            if (rev < Integer.MIN_VALUE / 10) {
                return 0;
            }
            rev = rev * 10 + pop; // 位于判断后，避免溢出
            x = x / 10;
        }
        return rev;
    }
}
```